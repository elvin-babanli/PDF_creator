16 Iterators and Generators
────────────────────────────────────────────
Overview
────────────────────────────────────────────
Iterators implement __iter__/__next__. Generators yield values lazily; generator expressions create on‑the‑fly sequences. Useful for streaming data without storing all in memory.

────────────────────────────────────────────
Example Code
────────────────────────────────────────────
def countdown(n):
    while n>0:
        yield n
        n -= 1

for v in countdown(3):
    print(v)

# generator expression
squares = (x*x for x in range(5))
print(list(squares))

────────────────────────────────────────────
Explanation
────────────────────────────────────────────
Each next() resumes execution after the last yield. Using generators reduces memory footprint and can improve performance on pipelines.

────────────────────────────────────────────
Question
────────────────────────────────────────────
Build a generator that yields even numbers up to n (inclusive).

────────────────────────────────────────────────
Answer
────────────────────────────────────────────────
def evens(n):
    for x in range(0, n+1, 2):
        yield x
